using System;
using System.Collections.Generic;

namespace Algorithms
{
    // Алгоритм

    // Основная идея - ищем максимальный элемент в неотсортированной части массива и ставим его в конец этого подмассива.
    // В поисках максимума подмассив перестраивается в так называемое сортирующее дерево (она же двоичная куча, она же пирамида),
    // в результате чего максимум сам "всплывает" в начало массива. После этого перемещаем максимум в конец подмассива.
    // Затем над оставшейся частью массива снова осуществляется процедура перестройки в сортирующее дерево с последующим
    // перемещением максимума в конец подмассива.

    // Сортирующее(неубывающее) дерево - дерево у которого любой родитель не меньше чем каждый из его потомков.
    // Если сортирующее дерево невозрастающее, то, соответственно, любой родитель не больше чем каждый из его потомков.

    // Сложность по времени:
    // - Худшая	 O(n * log n)
    // - Средняя O(n * log n)
    // - Лучшая  O(n * log n)

    // Сложность по памяти
    // - Общая O(n)
    // - Дополнительная O(1)

    public class HeapSort<T> : Base<T>
        where T : IComparable
    {
        public HeapSort() { }
        public HeapSort(IEnumerable<T> items) : base(items) { }

        protected override void MakeSort()
        {

        }
    }
}