using System;
using System.Collections.Generic;

// Одна из самых простейших сортировок.
// Не применяется для решения практических задач, ввиду низкой эффективности. (!!!!!)
// Быстро упорядочивает только массивы очень небольшого размера. С другой стороны, метод используется в учебных целях, поскольку лежит
// в основе некоторых других сортировок, более эффективных.

namespace Algorithms
{
    // Алгоритм
    // Осуществляется многократный прогон по массиву - сначала от первого до последнего элемента, потом от первого до предпоследнего,
    // потом от первого до третьего с конца и т.д. При прогоне сравниваются соседние элементы. Если они не упорядочены относительно друг друга,
    // то меняются местами. В результате при каждом прогоне в конец текущего подмассива всплывает наибольший (наименьший) элемент.

    // Сложность по времени:
    // - Худшая	 O(n * n)
    // - Средняя O(n * n)
    // - Лучшая  O(n)

    // Сложность по памяти
    // - Общая          O(n)
    // - Дополнительная O(1)

    public class BubbleSort<T> : Base<T>
        where T : IComparable
    {
        public BubbleSort() : base() { }
        public BubbleSort(IEnumerable<T> items) : base(items) { }

        /// <summary>
        /// Сортировка пузырьком (один прогон - минимальный в начале (и его не трогаем))
        /// </summary>
        protected override void MakeSort()
        {
            var count = Items.Count;
            for (var i = 0; i < count - 1; i++)
            {
                //IsSwapped = false;

                for (var j = i + 1; j < count; j++)
                {
                    T a = Items[i];
                    T b = Items[j];

                    if (Compare(a, b) == 1)
                    {
                        Swap(i, j);
                    }
                }

                //if (!IsSwapped)
                //    break;
            }
        }



        /// <summary>
        /// Сортировка пузырьком (один прогон - максимальный в конце (и его не трогаем))
        /// </summary>
        /*public override void Sort()
        {
            var count = Items.Count;
            for (var i = 0; i < count; i++)
            {
                for (var j = 0; j < count - i - 1; j++)
                {
                    T a = Items[j];
                    T b = Items[j + 1];

                    if (a.CompareTo(b) == 1)
                    {
                        Swap(j, j + 1);
                    }
                }
            }
        }*/
    }
}
