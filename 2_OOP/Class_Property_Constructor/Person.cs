using System;

namespace Class_Property_Constructor
{

    public class Person
    {
        // Конструктор по умолчанию
        public Person() : this ("Неизвестно", "Неизвестно")
        {
            Console.WriteLine("Сработал конструктор по умолчанию.");
        }

        // Конструктор пользовательский
        public Person(string name, string sName)
        {
            Console.WriteLine("Сработал пользовательский конструктор.");

            if (string.IsNullOrWhiteSpace(name) || string.IsNullOrWhiteSpace(sName))
            {
                throw new ArgumentNullException("Имя не может быть пустым");
            }

            Name = name;
            SecondName = sName;
        }


        // Статический конструктор
        /*
            - Статические конструкторы не должны иметь модификатор доступа и не принимают параметров.
            - Как и в статических методах, в статических конструкторах нельзя использовать ключевое слово this
            для ссылки на текущий объект класса и можно обращаться только к статическим членам класса.
            - Статические конструкторы нельзя вызвать в программе вручную. Они выполняются автоматически при
            самом первом создании объекта данного класса или при первом обращении к его статическим членам (если таковые имеются).
            - Статические конструкторы обычно используются для инициализации статических данных, либо же выполняют действия,
            которые требуется выполнить только один раз.
        */

        static Person()
        {
            normOfSteps = 8000;
            Console.WriteLine("Сработал статический конструктор.");
        }


        //******************************************************************************************//


        // Поле класса
        private string name;

        // Свои getter и setter
        public string GetName() => name;
        public void SetName(string name)
        {
            if (string.IsNullOrWhiteSpace(name))
            {
                throw new ArgumentNullException("Имя не может быть пустым");
            }

            this.name = name;
        }


        /*
            При использовании модификаторов в свойствах следует учитывать ряд ограничений:

            - Модификатор для блока set или get можно установить, если свойство имеет оба блока(и set, и get)
            - Только один блок set или get может иметь модификатор доступа, но не оба сразу.
            - Модификатор доступа блока set или get должен быть более ограничивающим, чем 
            модификатор доступа свойства. Например, если свойство имеет модификатор public, то блок set/get может
            иметь только модификаторы protected internal, internal, protected, private
        */

       // Свойство
       public string _Name
        {
            get => name;
            set
            {
                if (string.IsNullOrWhiteSpace(name))
                {
                    throw new ArgumentNullException("Имя не может быть пустым");
                }

                name = value;
            }
        }


        //******************************************************************************************//


        // Но можно представить в коротком виде - автосвойство.

        // - Стоит учитывать, что нельзя создать автоматическое свойство только для записи, как в случае со стандартными свойствами.
        // - Автосвойствам можно присвоить значения по умолчанию (инициализация автосвойств).
        // - Мы можем убрать блок set и сделать автосвойство доступным только для чтения.


        public string Name { get; set; }

        public string SecondName { get; set; }

        public string FullName
        {
            get => $"{SecondName} {Name}";
        }

        public static int normOfSteps;
    }
}
